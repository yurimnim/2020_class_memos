<<생성자>>
객체 생성시에 자동 수행되어 클래스의 멤버변수들의 값을 특정한 값으로 초기화할 목적으로 사용하는 특수한 메소드를 말한다. 
일반 메소드는 호출문에 의해서 동작. 그러나 생성자는 호출문에 의해 동작 하는게 아니라 
객체 생성시 자동으로 동작. 일반 메소드는 호출문에 의해서 메소드의 내용을 수행하고 
그 메소드의 내용이 끝나면 메소드 호출한 지점으로 되돌아 가게 되어있음.되돌아 가는 것을 return 이라고 한다. 
그러나 생성자는 호출문이 따로없음! 호출문에 의해 동작하는 것이 아니라 객체 생성시에 자동 수행 된다. 
따라서 return 의 개념이 없다!!!

생성자 만드는법::: 클래스 이름과 동일한 이름으로 메소드를 만들면 생성자로 동작한다. 
그러나 일반 메소드 처럼 return 타입은 적지않는다. 
return 의 개념이 생성자에는 없다. return 값이 없다고 void 를 쓰는것이 아님!!!
return 값이 없는것과 return의 개념이 없는 것은 다르다. 
return 값이 없다는 것은 return 하는데 값이 없다는 것이고 
return의 개념이 없다는 것은 호출문에 의해서 동작하는것이 아니라는것
따라서 생성자 이름앖에서는 아무것도 적지 않아야함. 

생성자는 중복하여 정의할 수 있다. 
중복하여 정의한다는 것은 생성자를 여러개 만들 수 있다는 말입니다. 
생성자를 중복정의하기 위해서는 매개변수의 개수가 다르거나 자료형이 달라야함. 


<< this와 this() >>
this는 생성자나 메소드의 매개변수 이름을 의미있는 이름으로 정해주다 보면 멤버변수 이름과 겹치게 된다. 
이때 멤버 자신을 구별할 목적으로 사용하는 키워드. 

this()는 생성자가 중복정의 되어있을 떼 생성자 속에서 또다른 생성자를 요구할 때 사용하는 키워드이다. 
this()는 반드시 첫번째 문장에 와야함!!!!!!!


<< 기본생성자 >>
매개변수를 하나도 갖지 않는 생성자를 말하며 
자바는 사용자가 생성자를 만들지 않으면 기본생성자를 제공한다.
//자료형에 따라 멤버변수들의 값이 자동으로 초기화 된다.// 
그러나 생성자를 만들기 시작하면 더이상 기본 생성자를 제공하지 않는다. 
따라서 필요하다면 기본생성자를 만들어야 한다. 

<<메소드 중복 method overloading>>
같은 이름의 메소드를 중복하여 정의하는 것을 말한다. 
이것을 위하여 매개변수의 개수가 다르거나 자료형이 달라야 한다. 

//클래스 이름에 가급적이면 하나의 클래스만 만들자//
//클래스 이름에 첫글자는 반드시 대문자로 하자//
//그러니 파일명도 첫글자는 대문자로 한다//
//파일명은 클래스 이름과 똑같이 해준다// 
//부득이하게 하나의 파일에 두개 이상의 클래스를 만들 때에는 
반드시 메인메소드 포함하는 클래스 이름으로 파일명 지정//

<<클래스 변수와 클래스 메소드(정적변수와 정적메소드)>>
일반적으로 클래스의 멤버변수는 객체를 생성해야지만 사용할 수 있고 객체마다 별도의 메모리가 확보
그러나 만약 객체와 무관하게 객체없이도 사용하고자 하는 변수가 있거나 모든 객체가 공동으로 사용할 기억공간이 
필요하다면 class 변수를 사용한다. 클래스 변수를 만드는 방법은 멤버변수명 앞에  static 키워드를 붙인다. 
클래스의 멤버변수명 앞에 static 키워드가 붙은 변수들을 클래스변수라고 한다. 
이것은 객체와 무관하게 객체없이도 사용할 수 있다. 객체없이 사용해야 하니 클래스 이름으로 접근한다. 
그래서 클래스변수라고 부른다. 만약, 객체가 있다면 객체를 통해서도 접근할 수 있다. 
이때는 모든객체가 공동으로 사용하는 기억공간이 된다. 

클래스메소드는 클래스변수와 마찬가지로 객체와 무관하게 객체없이도 사용할 수 있도록 하기위한 메소드이며 메소드명 앞에
 static 키워드를 붙이면 클래스 메소드가 된다. 일반적으로 어떠한 클래스의 일반 멤버 메소드를 사용하려면 반드시 객체를 생성하고
반드시 그 객체를 통해서 호출해야하지만  static 키워드가 붙은 클래스 메소드는 객체와 무관하게 객체없이도 호출할 수 있다. 
객체없이 호출해야하니 클래스 이름으로 접근. 

클래스메소드 안에서는 클래스 변수에만 접근할 수 있음.  